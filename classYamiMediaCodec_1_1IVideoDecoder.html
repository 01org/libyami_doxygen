<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libyami: YamiMediaCodec::IVideoDecoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libyami
   </div>
   <div id="projectbrief">libyami is core codec library basing on VAAPI</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceYamiMediaCodec.html">YamiMediaCodec</a></li><li class="navelem"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html">IVideoDecoder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classYamiMediaCodec_1_1IVideoDecoder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">YamiMediaCodec::IVideoDecoder Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract video decoding interface of libyami.  
 <a href="classYamiMediaCodec_1_1IVideoDecoder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VideoDecoderInterface_8h_source.html">VideoDecoderInterface.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for YamiMediaCodec::IVideoDecoder:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classYamiMediaCodec_1_1IVideoDecoder.png" usemap="#YamiMediaCodec::IVideoDecoder_map" alt=""/>
  <map id="YamiMediaCodec::IVideoDecoder_map" name="YamiMediaCodec::IVideoDecoder_map">
<area href="classYamiMediaCodec_1_1VaapiDecoderBase.html" alt="YamiMediaCodec::VaapiDecoderBase" shape="rect" coords="480,56,710,80"/>
<area href="classYamiMediaCodec_1_1VaapiDecoderFake.html" alt="YamiMediaCodec::VaapiDecoderFake" shape="rect" coords="0,112,230,136"/>
<area href="classYamiMediaCodec_1_1VaapiDecoderH264.html" alt="YamiMediaCodec::VaapiDecoderH264" shape="rect" coords="240,112,470,136"/>
<area href="classYamiMediaCodec_1_1VaapiDecoderJpeg.html" alt="YamiMediaCodec::VaapiDecoderJpeg" shape="rect" coords="480,112,710,136"/>
<area href="classYamiMediaCodec_1_1VaapiDecoderVP8.html" alt="YamiMediaCodec::VaapiDecoderVP8" shape="rect" coords="720,112,950,136"/>
<area href="classYamiMediaCodec_1_1VaapiDecoderVP9.html" alt="YamiMediaCodec::VaapiDecoderVP9" shape="rect" coords="960,112,1190,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afee3da0d293aa8ca4ed24e55c61bfb19"><td class="memItemLeft" align="right" valign="top">virtual Decode_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#afee3da0d293aa8ca4ed24e55c61bfb19">start</a> (<a class="el" href="structVideoConfigBuffer.html">VideoConfigBuffer</a> *buffer)=0</td></tr>
<tr class="memdesc:afee3da0d293aa8ca4ed24e55c61bfb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">configure decoder before decode the first frame  <a href="#afee3da0d293aa8ca4ed24e55c61bfb19">More...</a><br/></td></tr>
<tr class="separator:afee3da0d293aa8ca4ed24e55c61bfb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24f3dd91327eed0c2250700a32f4c64"><td class="memItemLeft" align="right" valign="top">virtual Decode_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#aa24f3dd91327eed0c2250700a32f4c64">reset</a> (<a class="el" href="structVideoConfigBuffer.html">VideoConfigBuffer</a> *buffer)=0</td></tr>
<tr class="memdesc:aa24f3dd91327eed0c2250700a32f4c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset decoder with new configuration before decoding a new stream  <a href="#aa24f3dd91327eed0c2250700a32f4c64">More...</a><br/></td></tr>
<tr class="separator:aa24f3dd91327eed0c2250700a32f4c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4d5574a84af8f757887e0d2cb250f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe4d5574a84af8f757887e0d2cb250f4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#abe4d5574a84af8f757887e0d2cb250f4">stop</a> (void)=0</td></tr>
<tr class="memdesc:abe4d5574a84af8f757887e0d2cb250f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop decoding and destroy sw/hw decoder context. <br/></td></tr>
<tr class="separator:abe4d5574a84af8f757887e0d2cb250f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087081d052695d617f5212372b13c7d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a087081d052695d617f5212372b13c7d0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a087081d052695d617f5212372b13c7d0">flush</a> (void)=0</td></tr>
<tr class="memdesc:a087081d052695d617f5212372b13c7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">discard cached data (input data or decoded video frames), it is usually required during seek <br/></td></tr>
<tr class="separator:a087081d052695d617f5212372b13c7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419b9b23b2f6e4010a01072b78ec7908"><td class="memItemLeft" align="right" valign="top">virtual Decode_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a419b9b23b2f6e4010a01072b78ec7908">decode</a> (<a class="el" href="structVideoDecodeBuffer.html">VideoDecodeBuffer</a> *buffer)=0</td></tr>
<tr class="memdesc:a419b9b23b2f6e4010a01072b78ec7908"><td class="mdescLeft">&#160;</td><td class="mdescRight">continue decoding with new data in  <a href="#a419b9b23b2f6e4010a01072b78ec7908">More...</a><br/></td></tr>
<tr class="separator:a419b9b23b2f6e4010a01072b78ec7908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508d584580b04b5ff53e44f23014778a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a508d584580b04b5ff53e44f23014778a"></a>
virtual SharedPtr&lt; <a class="el" href="structVideoFrame.html">VideoFrame</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a508d584580b04b5ff53e44f23014778a">getOutput</a> ()=0</td></tr>
<tr class="memdesc:a508d584580b04b5ff53e44f23014778a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get decoded frame from decoder. <br/></td></tr>
<tr class="separator:a508d584580b04b5ff53e44f23014778a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5552dd46d5df405794a1a03e25beb7b4"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structVideoRenderBuffer.html">VideoRenderBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a5552dd46d5df405794a1a03e25beb7b4">getOutput</a> (bool draining)=0</td></tr>
<tr class="memdesc:a5552dd46d5df405794a1a03e25beb7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return one frame to client for display; obsolete API. please use getOutput(XID, ...) or getOutput(<a class="el" href="structVideoFrameRawData.html">VideoFrameRawData</a>, ...) instead. NULL will be returned if no available frame for rendering  <a href="#a5552dd46d5df405794a1a03e25beb7b4">More...</a><br/></td></tr>
<tr class="separator:a5552dd46d5df405794a1a03e25beb7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438a363c46250dd525af8d3c80baf628"><td class="memItemLeft" align="right" valign="top">virtual Decode_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a438a363c46250dd525af8d3c80baf628">getOutput</a> (unsigned long draw, int64_t *timeStamp, int drawX, int drawY, int drawWidth, int drawHeight, bool draining=false, int frameX=-1, int frameY=-1, int frameWidth=-1, int frameHeight=-1)=0</td></tr>
<tr class="memdesc:a438a363c46250dd525af8d3c80baf628"><td class="mdescLeft">&#160;</td><td class="mdescRight">render one available video frame to draw  <a href="#a438a363c46250dd525af8d3c80baf628">More...</a><br/></td></tr>
<tr class="separator:a438a363c46250dd525af8d3c80baf628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba52ec6ef20cc414747ecc65b739bc3e"><td class="memItemLeft" align="right" valign="top">virtual Decode_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#aba52ec6ef20cc414747ecc65b739bc3e">getOutput</a> (<a class="el" href="structVideoFrameRawData.html">VideoFrameRawData</a> *frame, bool draining=false)=0</td></tr>
<tr class="memdesc:aba52ec6ef20cc414747ecc65b739bc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">export one frame to client buffer; there are four type to export one frame (VideoDataMemoryType); after rendering, client return the buffer back by <a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a3634c51ebd47cbecbe17c7e54456ed10" title="client recycles video frame (retrieve by getOutput) back to libyami after the buffer has been rendere...">renderDone(VideoFrameRawData*)</a>; RENDER_NO_AVAILABLE_FRAME will be returned if no available frame for rendering. if frame-&gt;fourcc or/and frame-&gt;width/height are set, color conversion or/and resize is done as well.  <a href="#aba52ec6ef20cc414747ecc65b739bc3e">More...</a><br/></td></tr>
<tr class="separator:aba52ec6ef20cc414747ecc65b739bc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29638eec24174344c442a6577e1d3602"><td class="memItemLeft" align="right" valign="top">virtual Decode_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a29638eec24174344c442a6577e1d3602">populateOutputHandles</a> (<a class="el" href="structVideoFrameRawData.html">VideoFrameRawData</a> *frames, unsigned int &amp;frameCount)=0</td></tr>
<tr class="separator:a29638eec24174344c442a6577e1d3602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78a5a58a1290d536febd56f8b98c33d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae78a5a58a1290d536febd56f8b98c33d"></a>
virtual const <a class="el" href="structVideoFormatInfo.html">VideoFormatInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#ae78a5a58a1290d536febd56f8b98c33d">getFormatInfo</a> (void)=0</td></tr>
<tr class="memdesc:ae78a5a58a1290d536febd56f8b98c33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve updated stream information after decoder has parsed the video stream. client usually calls it when libyami return DECODE_FORMAT_CHANGE in <a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a419b9b23b2f6e4010a01072b78ec7908" title="continue decoding with new data in ">decode()</a>. <br/></td></tr>
<tr class="separator:ae78a5a58a1290d536febd56f8b98c33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2165a0193086627458156275ba7d8a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a0b2165a0193086627458156275ba7d8a">renderDone</a> (const <a class="el" href="structVideoRenderBuffer.html">VideoRenderBuffer</a> *buffer)=0</td></tr>
<tr class="memdesc:a0b2165a0193086627458156275ba7d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">client recycles buffer back to libyami after the buffer has been rendered.  <a href="#a0b2165a0193086627458156275ba7d8a">More...</a><br/></td></tr>
<tr class="separator:a0b2165a0193086627458156275ba7d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3634c51ebd47cbecbe17c7e54456ed10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3634c51ebd47cbecbe17c7e54456ed10"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a3634c51ebd47cbecbe17c7e54456ed10">renderDone</a> (<a class="el" href="structVideoFrameRawData.html">VideoFrameRawData</a> *frame)=0</td></tr>
<tr class="memdesc:a3634c51ebd47cbecbe17c7e54456ed10"><td class="mdescLeft">&#160;</td><td class="mdescRight">client recycles video frame (retrieve by getOutput) back to libyami after the buffer has been rendered. <br/></td></tr>
<tr class="separator:a3634c51ebd47cbecbe17c7e54456ed10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac445a0f5e33ea8acc0c1a8e992c7eb91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac445a0f5e33ea8acc0c1a8e992c7eb91"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#ac445a0f5e33ea8acc0c1a8e992c7eb91">setNativeDisplay</a> (<a class="el" href="structNativeDisplay.html">NativeDisplay</a> *display=NULL)=0</td></tr>
<tr class="memdesc:ac445a0f5e33ea8acc0c1a8e992c7eb91"><td class="mdescLeft">&#160;</td><td class="mdescRight">set native display <br/></td></tr>
<tr class="separator:ac445a0f5e33ea8acc0c1a8e992c7eb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca717fb35ed607d680b9ae01909d2174"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#aca717fb35ed607d680b9ae01909d2174">releaseLock</a> (bool lockable=false)=0</td></tr>
<tr class="separator:aca717fb35ed607d680b9ae01909d2174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed22611456c0b4d3041310ee99f4401"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ed22611456c0b4d3041310ee99f4401"></a>
virtual VADisplay&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a1ed22611456c0b4d3041310ee99f4401">getDisplayID</a> ()=0</td></tr>
<tr class="memdesc:a1ed22611456c0b4d3041310ee99f4401"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not use this, we will remove this in near future <br/></td></tr>
<tr class="separator:a1ed22611456c0b4d3041310ee99f4401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d2c6e0588da9e70325b4b45ab71fda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06d2c6e0588da9e70325b4b45ab71fda"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a06d2c6e0588da9e70325b4b45ab71fda">flushOutport</a> (void)=0</td></tr>
<tr class="memdesc:a06d2c6e0588da9e70325b4b45ab71fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">obsolete, make all cached video frame output-able, it can be done by getOutput(draining=true) as well <br/></td></tr>
<tr class="separator:a06d2c6e0588da9e70325b4b45ab71fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61b5b7d933e8ec7f2174fee9864c4b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad61b5b7d933e8ec7f2174fee9864c4b8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#ad61b5b7d933e8ec7f2174fee9864c4b8">enableNativeBuffers</a> (void)=0</td></tr>
<tr class="memdesc:ad61b5b7d933e8ec7f2174fee9864c4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">not interest for now, may be used by Android to accept external video frame memory from gralloc <br/></td></tr>
<tr class="separator:ad61b5b7d933e8ec7f2174fee9864c4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaad5ddfc624a97c1629e3b70ba64d82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaad5ddfc624a97c1629e3b70ba64d82"></a>
virtual Decode_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#aaaad5ddfc624a97c1629e3b70ba64d82">getClientNativeWindowBuffer</a> (void *bufferHeader, void *nativeBufferHandle)=0</td></tr>
<tr class="memdesc:aaaad5ddfc624a97c1629e3b70ba64d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">not interest for now, may be used by Android to accept external video frame memory from gralloc <br/></td></tr>
<tr class="separator:aaaad5ddfc624a97c1629e3b70ba64d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ec31b1f4e51753d4a906bbdd088f28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45ec31b1f4e51753d4a906bbdd088f28"></a>
virtual Decode_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a45ec31b1f4e51753d4a906bbdd088f28">flagNativeBuffer</a> (void *pBuffer)=0</td></tr>
<tr class="memdesc:a45ec31b1f4e51753d4a906bbdd088f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">not interest for now, may be used by Android to accept external video frame memory from gralloc <br/></td></tr>
<tr class="separator:a45ec31b1f4e51753d4a906bbdd088f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract video decoding interface of libyami. </p>
<p>it is the interface with client </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a419b9b23b2f6e4010a01072b78ec7908"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Decode_Status YamiMediaCodec::IVideoDecoder::decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVideoDecodeBuffer.html">VideoDecodeBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>continue decoding with new data in </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer;</td><td>send empty data (buffer.data=NULL, buffer.size=0) to indicate EOS </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderH264.html#a16b638a6205c33159051bef04d73d73f">YamiMediaCodec::VaapiDecoderH264</a>, <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderVP8.html#abf4fbf679792e4055658d59bbf309337">YamiMediaCodec::VaapiDecoderVP8</a>, <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderVP9.html#a4e7a2ea09ad237915e2d336ef6ac14c6">YamiMediaCodec::VaapiDecoderVP9</a>, <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderFake.html#a3d0c0828621886f23dac9d33f953486d">YamiMediaCodec::VaapiDecoderFake</a>, and <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderJpeg.html#ac9aa7c3a0759c4aa479c385dda14cc3f">YamiMediaCodec::VaapiDecoderJpeg</a>.</p>

</div>
</div>
<a class="anchor" id="a5552dd46d5df405794a1a03e25beb7b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structVideoRenderBuffer.html">VideoRenderBuffer</a>* YamiMediaCodec::IVideoDecoder::getOutput </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>draining</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return one frame to client for display; obsolete API. please use getOutput(XID, ...) or getOutput(<a class="el" href="structVideoFrameRawData.html">VideoFrameRawData</a>, ...) instead. NULL will be returned if no available frame for rendering </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">draining</td><td>drain out all possible frames or not. it is set to true upon EOS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structVideoRenderBuffer.html">VideoRenderBuffer</a> to be rendered by client </dd></dl>

<p>Implemented in <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderBase.html#ab73322671c807ea0d81cd5ae3d38fb18">YamiMediaCodec::VaapiDecoderBase</a>.</p>

</div>
</div>
<a class="anchor" id="a438a363c46250dd525af8d3c80baf628"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Decode_Status YamiMediaCodec::IVideoDecoder::getOutput </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>draw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>timeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>drawX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>drawY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>drawWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>drawHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>draining</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frameX</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frameY</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frameWidth</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frameHeight</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>render one available video frame to draw </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">draw</td><td>a X11 drawable, Pixmap or Window ID. we do not use Drawable/XID type from X11/X.h because interface should be unique unconditionally </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in/out]</td><td>timeStamp, time stamp of current rendering frame (it is passed from client before) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">drawX/drawY/drawWidth/drawHeight</td><td>specify a rect to render on the draw </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">drawX</td><td>horizontal offset to render on the draw </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">drawY</td><td>vertical offset to render on the draw </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>rendering rect width on the draw </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>render rect height on the draw </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameX/frameY/frameWidth/frameHeight</td><td>specify a portion rect for rendering, default means the whole surface to render </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameX</td><td>horizontal offset of the video frame to render </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameY</td><td>vertical offset of the video frame to render </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameWidth</td><td>rect width of the video frame to render </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameHeight</td><td>rect height of the video frame to render</td></tr>
  </table>
  </dd>
</dl>
<p>default value of frameX/frameY/frameWidth/frameHeight means rendering the whole video frame(surface)</p>
<dl class="section return"><dt>Returns</dt><dd>DECODE_SUCCESS for success </dd>
<dd>
RENDER_NO_AVAILABLE_FRAME when no available frame to render </dd>
<dd>
RENDER_FAIL when driver fail to do vaPutSurface </dd>
<dd>
RENDER_INVALID_PARAMETER </dd></dl>

<p>Implemented in <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderBase.html#a63c59131f1afab4021b2e2d74029d524">YamiMediaCodec::VaapiDecoderBase</a>.</p>

</div>
</div>
<a class="anchor" id="aba52ec6ef20cc414747ecc65b739bc3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Decode_Status YamiMediaCodec::IVideoDecoder::getOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVideoFrameRawData.html">VideoFrameRawData</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>draining</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>export one frame to client buffer; there are four type to export one frame (VideoDataMemoryType); after rendering, client return the buffer back by <a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a3634c51ebd47cbecbe17c7e54456ed10" title="client recycles video frame (retrieve by getOutput) back to libyami after the buffer has been rendere...">renderDone(VideoFrameRawData*)</a>; RENDER_NO_AVAILABLE_FRAME will be returned if no available frame for rendering. if frame-&gt;fourcc or/and frame-&gt;width/height are set, color conversion or/and resize is done as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">draining</td><td>drain out all possible frames or not. it is set to true upon EOS. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderBase.html#a79977647abf25c217cbb3fcfc7611ebf">YamiMediaCodec::VaapiDecoderBase</a>.</p>

</div>
</div>
<a class="anchor" id="a29638eec24174344c442a6577e1d3602"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Decode_Status YamiMediaCodec::IVideoDecoder::populateOutputHandles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVideoFrameRawData.html">VideoFrameRawData</a> *&#160;</td>
          <td class="paramname"><em>frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>frameCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>in chromeos v4l2vda, it creates all EGLImage from output frames at initialization time, not create/destroy each frame texture on the fly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frames</td><td>the exported handles (and attributes) for all output frames. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in/out]</td><td>frameCount. the size of input frames when it is not zero. return the internal output pool size when it is zero. make sure to recycle (<a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a0b2165a0193086627458156275ba7d8a" title="client recycles buffer back to libyami after the buffer has been rendered. ">renderDone()</a>) these frames. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aca717fb35ed607d680b9ae01909d2174"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void YamiMediaCodec::IVideoDecoder::releaseLock </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lockable</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>lockable is set to false when seek begins and reset to true after seek is done EOS also set lockable to false </p>

<p>Implemented in <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderBase.html#a13e4342f0f869ac7e55fc80d2c33b87b">YamiMediaCodec::VaapiDecoderBase</a>.</p>

</div>
</div>
<a class="anchor" id="a0b2165a0193086627458156275ba7d8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void YamiMediaCodec::IVideoDecoder::renderDone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVideoRenderBuffer.html">VideoRenderBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>client recycles buffer back to libyami after the buffer has been rendered. </p>
<pre>
it is used by current omx client in async rendering mode.
if rendering target is passed in <a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a508d584580b04b5ff53e44f23014778a" title="get decoded frame from decoder. ">getOutput()</a>, then yami can does the rendering directly; this function becomes unnecessary.
however, this API is still useful when we export video frame directly for EGLImage (dma_buf).
</pre> 
<p>Implemented in <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderBase.html#a7f6eca8f7607ed8aa5ae1bc1496857ce">YamiMediaCodec::VaapiDecoderBase</a>.</p>

</div>
</div>
<a class="anchor" id="aa24f3dd91327eed0c2250700a32f4c64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Decode_Status YamiMediaCodec::IVideoDecoder::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVideoConfigBuffer.html">VideoConfigBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reset decoder with new configuration before decoding a new stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>new stream information to reset decoder. cached data (input data or decoded video frames) are discarded. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderH264.html#ab7a29372262a441409631bf16e80b078">YamiMediaCodec::VaapiDecoderH264</a>, <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderBase.html#a1a8b2f6934a863449abbe7d45b3825f4">YamiMediaCodec::VaapiDecoderBase</a>, <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderVP8.html#a4a5a17cc955dc765df3a9e2cb8e14c0b">YamiMediaCodec::VaapiDecoderVP8</a>, <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderVP9.html#aac1fd2acf8827ae610386a31b670fec1">YamiMediaCodec::VaapiDecoderVP9</a>, and <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderJpeg.html#aa2f0dd5a1d986dd8456acbdd8850e139">YamiMediaCodec::VaapiDecoderJpeg</a>.</p>

</div>
</div>
<a class="anchor" id="afee3da0d293aa8ca4ed24e55c61bfb19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Decode_Status YamiMediaCodec::IVideoDecoder::start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVideoConfigBuffer.html">VideoConfigBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>configure decoder before decode the first frame </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>stream information to initialize decoder if the configuration in </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>doesn't match the information in coming stream, future <a class="el" href="classYamiMediaCodec_1_1IVideoDecoder.html#a419b9b23b2f6e4010a01072b78ec7908" title="continue decoding with new data in ">decode</a> will return DECODE_FORMAT_CHANGE (#VIDEO_DECODE_STATUS), it will trigger a reconfiguration from client. (yami will not reconfigure decoder internally to avoid mismatch between client and libyami) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderH264.html#a72298fbacd540f69eea8c59d7eee6c04">YamiMediaCodec::VaapiDecoderH264</a>, <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderBase.html#a64ae7b892ee778c0f62d91b4727a63db">YamiMediaCodec::VaapiDecoderBase</a>, <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderVP8.html#aab300b36d5f592d297386112c3b82a4f">YamiMediaCodec::VaapiDecoderVP8</a>, <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderVP9.html#adea515ed78d71c0a77fa4aceebf6d516">YamiMediaCodec::VaapiDecoderVP9</a>, <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderFake.html#aa8bcba915c41394f45a0a109732e0771">YamiMediaCodec::VaapiDecoderFake</a>, and <a class="el" href="classYamiMediaCodec_1_1VaapiDecoderJpeg.html#af7ede374f58d2b1e6fd192f9b36a09eb">YamiMediaCodec::VaapiDecoderJpeg</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/thomas/projects/yami/release/libyami/interface/<a class="el" href="VideoDecoderInterface_8h_source.html">VideoDecoderInterface.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 8 2015 10:01:18 for libyami by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
